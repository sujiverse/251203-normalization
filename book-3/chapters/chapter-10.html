<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10장: 트러블슈팅 & 유지보수 - 물리치료사를 위한 데이터베이스 3권</title>
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    @@include('components/top-nav.html', {"root": "../..", "activeBook": "3"})

    @@include('components/mobile-menu.html')
    <div class="container">
        <nav class="sidebar" id="sidebar">
            <button class="close-btn" onclick="toggleMenu()">×</button>
            <div class="sidebar-header">
                <h1>📙 물리치료사를 위한</h1>
                <p>실전 구축 & 대시보드 (3권)</p>
            </div>
            <ul class="nav-list" id="navList"></ul>
        </nav>
        <main class="main">
<h1 class="title">트러블슈팅 & 유지보수</h1>

<h2>문제는 반드시 발생합니다</h2>

<p>아무리 잘 만든 데이터베이스도 문제가 생길 수 있습니다. 쿼리가 갑자기 느려지고, 연결이 안 되고, 디스크가 가득 차고... 이런 상황에 당황하지 않으려면 미리 대처 방법을 알아두어야 합니다.</p>

<p>이번 장에서는 자주 발생하는 문제와 해결 방법, 그리고 문제가 생기지 않도록 예방하는 유지보수 방법을 다룹니다.</p>

<h3>이번 장에서 다룰 내용</h3>

<ul>
<li>자주 발생하는 에러와 해결법</li>
<li>느려진 쿼리 진단 및 개선</li>
<li>데이터베이스 백업과 복원</li>
<li>정기 유지보수 작업</li>
<li>모니터링 쿼리</li>
</ul>

<hr>

<h2>1. 자주 발생하는 에러와 해결법</h2>

<h3>에러 1: 연결 안 됨</h3>

<pre><code>ERROR 2003 (HY000): Can't connect to MySQL server on 'localhost' (10061)</code></pre>

<p><strong>원인:</strong> MySQL 서버가 실행 중이 아님</p>

<p><strong>해결:</strong></p>
<pre><code>-- Windows: 서비스 시작
net start mysql

-- Mac/Linux: 서버 시작
mysql.server start
-- 또는
sudo systemctl start mysql</code></pre>

<h3>에러 2: 접근 거부</h3>

<pre><code>ERROR 1045 (28000): Access denied for user 'root'@'localhost'</code></pre>

<p><strong>원인:</strong> 비밀번호가 틀렸거나 권한 없음</p>

<p><strong>해결:</strong></p>
<ul>
<li>비밀번호 다시 확인</li>
<li>DBeaver 연결 설정에서 비밀번호 재입력</li>
<li>비밀번호를 잊었다면 MySQL 비밀번호 재설정 필요</li>
</ul>

<h3>에러 3: 외래키 제약 위반</h3>

<pre><code>ERROR 1452 (23000): Cannot add or update a child row:
a foreign key constraint fails</code></pre>

<p><strong>원인:</strong> 참조하려는 값이 부모 테이블에 없음</p>

<p><strong>해결:</strong></p>
<pre><code>-- 예: 환자에게 'INS999' 보험사를 지정하려는데 없음
-- 1. 먼저 부모 테이블에 값이 있는지 확인
SELECT * FROM insurances WHERE insurance_code = 'INS999';

-- 2-1. 없으면 먼저 추가하거나
INSERT INTO insurances (insurance_code, insurance_name, insurance_type)
VALUES ('INS999', '새로운보험사', '실손보험');

-- 2-2. 존재하는 값으로 변경
UPDATE patients SET insurance_code = 'INS001' WHERE patient_id = 'P001';</code></pre>

<h3>에러 4: 중복 키</h3>

<pre><code>ERROR 1062 (23000): Duplicate entry 'P001' for key 'PRIMARY'</code></pre>

<p><strong>원인:</strong> 이미 존재하는 기본키로 INSERT 시도</p>

<p><strong>해결:</strong></p>
<pre><code>-- 해당 키가 이미 있는지 확인
SELECT * FROM patients WHERE patient_id = 'P001';

-- 다른 ID로 입력하거나, UPDATE로 수정</code></pre>

<h3>에러 5: 테이블이 없음</h3>

<pre><code>ERROR 1146 (42S02): Table 'healing_hands.patient' doesn't exist</code></pre>

<p><strong>원인:</strong> 테이블 이름 오타 또는 데이터베이스 선택 안 됨</p>

<p><strong>해결:</strong></p>
<pre><code>-- 현재 선택된 데이터베이스 확인
SELECT DATABASE();

-- 데이터베이스 선택
USE healing_hands;

-- 테이블 목록 확인 (오타 찾기)
SHOW TABLES;

-- patients인데 patient로 썼네요!</code></pre>

<h3>에러 6: 삭제 불가 (참조되는 데이터)</h3>

<pre><code>ERROR 1451 (23000): Cannot delete or update a parent row:
a foreign key constraint fails</code></pre>

<p><strong>원인:</strong> 이 데이터를 참조하는 다른 데이터가 있음</p>

<p><strong>해결:</strong></p>
<pre><code>-- 예: 환자를 삭제하려는데 치료 기록이 있음
-- 1. 참조하는 데이터 확인
SELECT * FROM treatment_sessions WHERE patient_id = 'P001';

-- 2. 자식 데이터를 먼저 삭제하거나 (비추천)
-- 3. 삭제 대신 비활성화 (추천)
UPDATE patients SET is_active = 'N' WHERE patient_id = 'P001';</code></pre>

<hr>

<h2>2. 느려진 쿼리 진단 및 개선</h2>

<p>갑자기 쿼리가 느려졌다면? 원인을 찾아서 해결해야 합니다.</p>

<h3>EXPLAIN으로 쿼리 분석</h3>

<p>쿼리 앞에 <code>EXPLAIN</code>을 붙이면 MySQL이 어떻게 실행할지 보여줍니다.</p>

<pre><code>-- 이 쿼리가 느리다면?
EXPLAIN
SELECT p.name, COUNT(*) as 치료횟수
FROM patients p
JOIN treatment_sessions ts ON p.patient_id = ts.patient_id
WHERE ts.session_date BETWEEN '2024-01-01' AND '2024-03-31'
GROUP BY p.patient_id;</code></pre>

<p>결과에서 주목할 부분:</p>

<table>
<tr><th>항목</th><th>좋은 값</th><th>나쁜 값</th></tr>
<tr><td>type</td><td>ref, eq_ref, const</td><td>ALL (전체 스캔)</td></tr>
<tr><td>key</td><td>인덱스 이름</td><td>NULL (인덱스 안 씀)</td></tr>
<tr><td>rows</td><td>작은 숫자</td><td>큰 숫자 (많이 스캔)</td></tr>
</table>

<h3>느린 쿼리 개선 방법</h3>

<h4>방법 1: 인덱스 추가</h4>

<pre><code>-- session_date로 자주 검색한다면 인덱스 추가
CREATE INDEX idx_session_date ON treatment_sessions(session_date);

-- 다시 EXPLAIN 해보면 type이 개선됨</code></pre>

<h4>방법 2: 쿼리 최적화</h4>

<pre><code>-- 나쁜 예: SELECT *
SELECT * FROM patients WHERE name LIKE '%민%';

-- 좋은 예: 필요한 컬럼만
SELECT patient_id, name, phone FROM patients WHERE name LIKE '%민%';

-- 나쁜 예: LIKE '%...%' (인덱스 못 씀)
SELECT * FROM patients WHERE name LIKE '%민준%';

-- 좋은 예: LIKE '...%' (인덱스 사용 가능)
SELECT * FROM patients WHERE name LIKE '강민%';</code></pre>

<h3>현재 실행 중인 쿼리 확인</h3>

<pre><code>-- 지금 실행 중인 쿼리들
SHOW PROCESSLIST;

-- 오래 걸리는 쿼리 강제 종료 (Id를 확인 후)
KILL 123;</code></pre>

<hr>

<h2>3. 데이터베이스 백업과 복원</h2>

<p>데이터베이스에서 가장 중요한 건 <strong>백업</strong>입니다. 백업 없이 운영하다가 문제가 생기면 모든 데이터를 잃을 수 있어요.</p>

<h3>mysqldump로 백업</h3>

<pre><code># 터미널/명령 프롬프트에서 실행 (SQL 안에서 X)

# 전체 데이터베이스 백업
mysqldump -u root -p healing_hands > healing_hands_backup_20240325.sql

# 특정 테이블만 백업
mysqldump -u root -p healing_hands patients treatment_sessions > patients_sessions_backup.sql

# 구조만 백업 (데이터 제외)
mysqldump -u root -p --no-data healing_hands > healing_hands_structure.sql</code></pre>

<h3>백업 파일로 복원</h3>

<pre><code># 데이터베이스 복원
mysql -u root -p healing_hands < healing_hands_backup_20240325.sql

# 새 데이터베이스에 복원
mysql -u root -p -e "CREATE DATABASE healing_hands_restored"
mysql -u root -p healing_hands_restored < healing_hands_backup_20240325.sql</code></pre>

<div class="danger"><strong>🚨 백업의 3-2-1 규칙</strong><br>
<ul>
<li><strong>3</strong>개의 복사본 유지</li>
<li><strong>2</strong>가지 다른 매체에 저장 (로컬 + 외장하드 또는 클라우드)</li>
<li><strong>1</strong>개는 외부 장소에 (클라우드, 다른 사무실)</li>
</ul>
</div>

<hr>

<h2>4. 정기 유지보수 작업</h2>

<h3>매일 할 일</h3>

<pre><code>-- 1. 데이터 무결성 간단 체크
SELECT
(SELECT COUNT(*) FROM treatment_sessions) as 치료건수,
(SELECT COUNT(*) FROM billings) as 청구건수,
(SELECT COUNT(*) FROM treatment_sessions) - (SELECT COUNT(*) FROM billings) as 차이;
-- 차이가 0이어야 정상 (모든 치료에 청구가 있어야 함)</code></pre>

<h3>매주 할 일</h3>

<pre><code>-- 1. 테이블 상태 확인
SHOW TABLE STATUS FROM healing_hands;

-- 2. 인덱스 통계 업데이트
ANALYZE TABLE patients, treatment_sessions, billings;</code></pre>

<h3>매월 할 일</h3>

<pre><code>-- 1. 테이블 최적화 (조각 모음)
OPTIMIZE TABLE patients;
OPTIMIZE TABLE treatment_sessions;
OPTIMIZE TABLE billings;</code></pre>

<hr>

<h2>5. 모니터링 쿼리</h2>

<p>데이터베이스 상태를 주기적으로 체크하는 쿼리들입니다.</p>

<h3>데이터베이스 크기 확인</h3>

<pre><code>-- 데이터베이스 전체 크기
SELECT
table_schema AS '데이터베이스',
ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS '크기(MB)'
FROM information_schema.tables
WHERE table_schema = 'healing_hands'
GROUP BY table_schema;</code></pre>

<h3>테이블별 크기 확인</h3>

<pre><code>-- 테이블별 크기
SELECT
table_name AS '테이블',
ROUND(data_length / 1024 / 1024, 2) AS '데이터(MB)',
ROUND(index_length / 1024 / 1024, 2) AS '인덱스(MB)',
table_rows AS '행수'
FROM information_schema.tables
WHERE table_schema = 'healing_hands'
ORDER BY (data_length + index_length) DESC;</code></pre>

<h3>연결 상태 확인</h3>

<pre><code>-- 현재 연결 수
SHOW STATUS LIKE 'Threads_connected';

-- 최대 연결 수 설정
SHOW VARIABLES LIKE 'max_connections';</code></pre>

<hr>

<h2>6. 유지보수 체크리스트</h2>

<table>
<tr><th>주기</th><th>작업</th><th>담당</th><th>체크</th></tr>
<tr><td>매일</td><td>백업 실행 확인</td><td>자동/담당자</td><td>☐</td></tr>
<tr><td>매일</td><td>에러 로그 확인</td><td>담당자</td><td>☐</td></tr>
<tr><td>매주</td><td>백업 파일 무결성 확인</td><td>담당자</td><td>☐</td></tr>
<tr><td>매주</td><td>디스크 공간 확인</td><td>담당자</td><td>☐</td></tr>
<tr><td>매월</td><td>테이블 최적화</td><td>담당자</td><td>☐</td></tr>
<tr><td>매월</td><td>인덱스 상태 점검</td><td>담당자</td><td>☐</td></tr>
<tr><td>분기</td><td>전체 테이블 점검</td><td>담당자</td><td>☐</td></tr>
<tr><td>분기</td><td>백업 복원 테스트</td><td>담당자</td><td>☐</td></tr>
</table>

<hr>

<h2>이번 장 요약</h2>

<p>이번 장에서 배운 것:</p>

<ol>
<li><strong>자주 발생하는 에러</strong>와 해결 방법</li>
<li><strong>EXPLAIN</strong>으로 느린 쿼리 진단</li>
<li><strong>mysqldump</strong>로 백업과 복원</li>
<li><strong>정기 유지보수</strong> 작업 (매일/매주/매월/분기)</li>
<li><strong>모니터링 쿼리</strong>로 상태 체크</li>
<li><strong>응급 상황</strong> 대응 방법</li>
</ol>

<p>핵심 메시지: <strong>"백업은 선택이 아니라 필수!"</strong></p>

<p>데이터베이스 부분이 완료되었습니다! 다음 장부터는 Metabase를 사용해서 시각적인 대시보드를 만듭니다. 지금까지 쿼리로 보던 데이터를 예쁜 차트와 그래프로 볼 수 있게 됩니다!</p>

            <div class="nav-buttons">
                <button class="nav-btn" id="prevBtn">← 이전</button>
                <span class="page-num" id="pageNum"></span>
                <button class="nav-btn" id="nextBtn">다음 →</button>
            </div>
        </main>
    </div>
    <script src="../js/nav.js"></script>
</body>
</html>
